### 用户在浏览器中输入链接后，到展示页面，这中间发生了什么？

1. 输入的网址在通过DNS解析后得到服务器地址

2. 浏览器向服务器发送http请求

3. 经过TCP三次握手确认链接

4. 服务器将需要的代码发送给浏览器

5. 浏览器通过三大步骤将服务器代码进行解析

   1. DOM构造：通过html解析器，解析为一颗DOM树；css解析器构建出样式表规则，将规则放到对应DOM节点上
   2. 布局：浏览器通过从上到下，从左到右的顺序，读取DOM树的节点，节点放在一条虚拟的传送带上，这就是文档流。再通过计算节点的大小及css属性，一一摆放到浏览器页面
   3. 绘制页面

   面试回答：将代码解析成DOM树，然后按照从上到下，从左到右的顺序，将树上的节点压入文档流，然后布局



### 三次握手





### 语义化的理解

header、footer、main ⽤正确的标签做正确的事情！

HTML 语义化就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析；



### 你对浏览器内核的理解？

主要分成两部分：渲染引擎和 JS 引擎

* **渲染引擎**：负责取得⽹⻚的内容（ HTML 、 XML 、图像等等）、以及计算⽹⻚的显示⽅式，然后会输出⾄显示器

* **JS 引擎**：解析和执⾏ javascript 来实现⽹⻚的动态效果



### html5有哪些新特性

绘画 canvas 

⽤于媒介回放的 video 和 audio 元素 

本地离线存储 localStorage ⻓期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后⾃动删除 

语意化更好的内容元素

新的技术 webworker 、 websocket

###  URL最长字符长度



### cookies ， sessionStorage 和 localStorage 的区别？

* cookie 是⽹站为了标示⽤户身份⽽储存在⽤户本地终端（Client Side）上的数据（通常 经过加密） 

* cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回 传递 

* sessionStorage 和 localStorage 不会⾃动把数据发给服务器，仅在本地保存 

**存储⼤⼩：** 

cookie 数据⼤⼩不能超过4k 

sessionStorage 和 localStorage 虽然也有存储⼤⼩的限制，但⽐ cookie ⼤得 多，可以达到5M或更⼤ 



**有期时间**： 

localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据 

sessionStorage 数据在当前浏览器窗⼝关闭后⾃动删除 

cookie 设置的 cookie 过期时间之前⼀直有效，即使窗⼝或浏览器关闭



### ⾏内元素有哪些？块级元素有哪些？

⾏内元素有：` a b span img input select strong `

块级元素有： `div ul ol li dl dt dd h1 h2 h3 h4… p`

**⾏内元素不可以设置宽⾼，不独占⼀⾏** 

**块级元素可以设置宽⾼，独占⼀⾏**



### Canvas和SVG有什么区别？

* svg 绘制出来的每⼀个图形的元素都是独⽴的 DOM 节点，能够⽅便的绑定事件或⽤来修 改。 canvas 输出的是⼀整幅画布

* svg 输出的图形是⽮量图形，后期可以修改参数来⾃由放⼤缩⼩，不会失真和锯⻮。⽽ canvas 输出标量画布，就像⼀张图⽚⼀样，放⼤会失真或者锯⻮

### viewport 

<meta name="viewport" content="width=device-width,initial-scale=1.0,minimu
 // width 设置viewport宽度，为⼀个正整数，或字符串‘device-width’
 // device-width 设备宽度
 // height 设置viewport⾼度，⼀般设置了宽度，会⾃动解析出⾼度，可以不⽤设置
 // initial-scale 默认缩放⽐例（初始缩放⽐例），为⼀个数字，可以带⼩数
 // minimum-scale 允许⽤户最⼩缩放⽐例，为⼀个数字，可以带⼩数
 // maximum-scale 允许⽤户最⼤缩放⽐例，为⼀个数字，可以带⼩数
 // user-scalable 是否允许⼿动缩放

延伸提问 **怎样处理 移动端 1px 被 渲染成 2px 问题 ?**

* 局部处理 

  mate 标签中的 viewport 属性 ， initial-scale 设置为 1 rem 按照设计稿标准⾛，外加利⽤ transfrome 的 scale(0.5) 缩⼩⼀倍即可；

* 全局处理 

  mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5 rem 按照设计稿标准⾛即可



### css设置三栏布局的方式

#### float

> 优点：设置简单。缺点：还需要清除浮动

```html
<section>
  <style>
    .box.float div {
      height: 300px;
    }

    .float .left {
      width: 300px;
      float: left;
      background-color: #ccc;
    }

    .float .right {
      width: 300px;
      float: right;
      background-color: antiquewhite;
    }

    .float .main {
      background-color: red;
    }
  </style>
  <div class="box float">
    <div class="left"></div>
    <div class="right"></div>
    <div class="main">
      float布局
    </div>
  </div>
</section>
```

#### absolute布局

> 缺点：脱离文档流，以后的内容也要脱离文档

```html
<section>
  <style>
    .absolute div {
      position: absolute;
      height: 300px;
    }

    .absolute .left {
      left: 0;
      width: 300px;
      background-color: #ccc;
    }

    .absolute .right {
      right: 0;
      width: 300px;
      background-color: antiquewhite;
    }

    .absolute .main {
      background-color: red;
      left: 300px;
      right: 300px;
    }
  </style>
  <div class="box absolute">
    <div class="left"></div>
    <div class="main">
      absolute布局
    </div>
    <div class="right"></div>
  </div>
</section>
```

#### flex布局

> 优点：flex的出现就是为了解决float和absolute布局的缺点。特点：中间高度增加时，两边不会自动增加

```html
<section>
  <style>
    .flex {
      display: flex;
    }

    .flex div {
      height: 300px;
    }

    .flex .left,
    .flex .right {
      width: 300px;
    }

    .main {
      flex: 1;
      background-color: red;
    }

    .left {
      background-color: #ccc;
    }

    .right {
      background-color: antiquewhite;
    }
  </style>
  <div class="box flex">
    <div class="left"></div>
    <div class="main">
      flex布局
    </div>
    <div class="right"></div>
  </div>
</section>
```

#### *table布局*

> 优点：使用简单，缺点：历史遗留问题多。特点：中间高度增加时，两边会自动增加

```html
<section>
  <style>
    .table {
      width: 100%;
      height: 300px;
      display: table;
    }

    .table div {
      display: table-cell;
    }

    .table .left {
      background-color: #ccc;
      width: 300px;
    }

    .table .main {
      background-color: red;
    }

    .table .right {
      background-color: antiquewhite;
      width: 300px;
    }
  </style>
  <div class="box table">
    <div class="left"></div>
    <div class="main">
      Table布局
    </div>
    <div class="right"></div>
  </div>
</section>
```

#### grid网格布局

> 优点：css3为了分栏布局出的新特性。缺点：兼容性

```html
<section>
  <style>
    .grid {
      width: 100%;
      display: grid;
      grid-template-rows: 300px;
      grid-template-columns: 300px auto 300px;
    }

    .left {
      background-color: #ccc;
    }

    .main {
      background-color: red;
    }

    .right {
      background-color: antiquewhite;
    }
  </style>
  <div class="box grid">
    <div class="left"></div>
    <div class="main">
      grid布局
    </div>
    <div class="right"></div>
  </div>
</section>
```



### 盒子模型

> 盒子模型：margin+border+padding+content

box-sizing: content-box（默认），元素的宽高只会决定内容（content）的大小。
box-sizing: border-box  改变计算元素width和height的方式，border和padding的大小也将计算在内。

**标准盒模型**：宽高 = content的宽高
**IE盒模型：**宽高=content+padding+border

#### JS获取盒模型的宽高

* `dom.style.width/height` 

  这个只能获取到内联属性style的宽高，并不能获取到真实的宽高

* `dom.currentSrtle.width/height`

  这个可以获取到最后真实的宽高，但是只支持IE

* `window.getComputedStyle(dom).width/height`

  这个可以获取到真实宽高，并支持IE和Google浏览器

* `dom.getBoundingClientRect().width/height`

  这个除了可以获取真实宽高，还可以获取当前元素距离浏览器左上角的x和y轴的距离



### 什么是外边距合并/重叠

外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。

合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。



如果是空元素，则取空元素的margin-top或margin-bottom（哪个值大取哪个），来作为最大边距来合并



#### BFC

> 解决边距合并/重叠的问题

**基本概念：**块级格式化上下文。   （IFC：内联元素的格式化上下文，面试问的比较少）

BFC**原理：**

1. BFC这个元素垂直方向的边距，会发生重叠
2. BFC区域，不会和浮动元素进行重叠
3. BFC是一个单独的容器，外面的元素不会影响里面的元素，反过来亦是如此
4. 计算BFC高度时，浮动元素也会参与计算

**如何创建BFC：**

* float值不为null，即当前元素就是BFC
* position的值不是static/relative，即当前元素就是BFC
* display为inline-box，或和table相关的属性，即当前元素就是BFC
* overflow为auto/hidden，即当前元素就是BFC

**BFC的使用场景：**

场景一：防止边距重叠

```html
<section>
  <style>
    #content {
      background-color: #ccc;
    }
    #content p {
      margin: 5px auto 20px;
      background-color: aqua;
    }
  </style>
  <div id="content">
    <p>1</p>
    <div style="overflow: hidden;">		<!-- 给父级增加overflow，形成BFC防止边距重叠 -->
      <p>2</p>
    </div>
    <p>3</p>
  </div>
</section>
```

场景二：布局中不与float重叠

```html
<section>
  <style>
    #box {
      background-color: #ccc;
    }
    .content {
      float: left;
      width: 100px;
      height: 100px;
      background-color: palevioletred;
    }
    .other {
      overflow: hidden;		/* 使用BFC */
      height: 110px;
      background-color: pink;
    }
  </style>
  <div id="box">
    <div class="content"></div>
    <div class="other"></div>
  </div>
</section>
```

场景三：计算BFC高度，并清除浮动

```html
<section>
  <style>
    #float{
      background-color: red;
      float: left;
      /* overflow: hidden; */   /* 两中创建BFC的方法都可以 */
    }
    .float{
      float: left;
    }
  </style>
  <div id="float">
    <div class="float">
      我是float元素
    </div>
  </div>
</section>
```

### Dom事件

#### Dom事件的级别

DOM0：`dom.onclick=function(){}`

DOM2：`dom.addEventListener('click',function(){},false)`

DOM3：`dom.addEventListener('keyup',function(){},false)`	二级三级的区别就是，三级更多是键盘/鼠标的事件监听

#### Dom事件模型

* 冒泡事件
* 捕获事件

#### Dom事件流

事件从捕获，到达目标阶段（目标元素），再从目标阶段，冒泡到window

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——DOM事件流.png)

#### 描述Dom事件捕获的具体流程

window => document => html => body => ... 目标元素

#### Event对象的常见应用

* event.preventDefault()   阻止默认事件，如a标签的跳转
* event.stopPropagation()   阻止事件冒泡
* event.stopImmediateProgagation()   当绑定两个click事件时，点击则会执行AB两个事件。如果在A函数中使用这个方法，则会停止执行函数B
* event.currentTarget  当前被绑定事件的元素
* event.target   当前被点击的元素

#### 自定义事件

```js
let btnEle = document.querySelector('#btn')

let eve = new CustomEvent('custome',{detail:'我是自定义数据'})		// 通过对象内置的detail来传递数据
btnEle.addEventListener('custome',function (params) {
  console.log('custome',params.detail);
})
btnEle.dispatchEvent(eve) // 发送事件，一般在setTimeout中f
```

### 原型链

#### 创建对象有几种方法

* 字面量

  ```js
  var o1 = {name:'o1'}
  var o2 = new Object({name:'o2'})
  ```

* 构造函数

  ```js
  var M = function(name){this.name = name}
  var o3 = new M('o3')
  ```

* Object.create

  ```js
  var protoObj = {name:'vicer'}
  var o4 = Object.create(protoObj)
  // 注意：直接打印o4看不到当前对象中的name，因为：使用create创建的实例是新对象，它继承了构造函数的原型对象
  // 即 o4 = {}; 
  // 	  o4.__proto__ === protoObj
  // 根据原型链的向上查找，所以o4.name === 'vicer'。如果不懂可以看完下方的原型链及new运算符原理再回来看这个
  ```
  
  

#### 原型、构造函数、实例、原型链

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——原型链.png)

实例：只要是一个对象，那么这个对象便是一个实例

构造函数：只要这个函数被new了，那么这个函数就是构造函数

原型对象：只要函数被创建了，这个函数就会被js自动加上prototype，并赋值一个空对象，那么这个对象就是原型对象

原型链：当前实例通过`_proto_`向上查找，有一个原型对象，原型对象继续向上查找，又有一个创建它的原型对象，直到`Object.prototype`为止，这个就是原型链

#### instanceof的原理

本质上就是判断`实例对象`的`_proto_`，与`构造函数`的`prototype`是否指向一个原型，如果是，则返回true

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——原型链2.png)

为什么instanceof也可以判断实例是否是Object，比如（`o3 instanceof Object`），

因为即实例的原型对象，是通过new构造函数得到的。而所有对象最终都指向Object，他们与实例都在一条原型链上，根据原型链向上查找原理，所以可以通过instanceof判断当前实例是Object还是Array，即`o3.__proto__.__proto__ === Object.prototype // =>true`，

#### new运算符的工作原理

1. 一个新对象被创建。它继承自构造函数的prototype => **原型对象**，如`fun.prototype`

2. 构造函数`fun`被执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。

   `new fun等同于new fun()，只能用在不传递任何参数的情况`

3. 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象

```js
// 模拟new运算符工作原理
let newSymbol = function(fun,arg){
  // create方法创建的是空对象，并且给这个空对象的prototype进行赋值（继承）fun.prototype
	let obj = Object.create(fun.prototype)	
  let bindObj = fun.call(obj,arg)
  if(typeof bindObj === 'object'){
		return bindObj
	}else{
    return obj
  }
}

var M = function(name){
  this.name = name
  //return {name}
}
// var o3 = new M('o3')
var o3 = newSymbol(M,'o3')  // 模拟new工作原理
```



### 面向对象类

#### 类与实例

##### 类的声明

```js
// ES5的声明
function Animal() {		// 如果这个函数是构造函数，记得函数名大写驼峰
  this.name = 'Animal';
};

// es6中class的声明
class Animal2 {
  constructor () {
    this.name = 'Animal2';
  }
}
```

##### 生成实例

只需New即可生成实例

```js
// 实例化
console.log(new Animal(), new Animal2());
```

#### 类与继承

##### 如何实现继承，继承的几种方式

1. 借助call方法实现继承           

   ```js
   function Parent1 () {
     this.name = 'parent1';
   }
   Parent1.prototype.say = function () {
   
   };
   function Child1 () {
     Parent1.call(this);
     this.type = 'child1';
   }
   console.log(new Child1(), new Child1().say());
   // 缺点：无法继承构造函数的prototype
   ```

2. 借助原型链实现继承

   ```js
   function Parent2 () {
     this.name = 'parent2';
     this.play = [1, 2, 3];
   }
   function Child2 () {
     this.type = 'child2';
   }
   Child2.prototype = new Parent2();
   
   var s1 = new Child2();
   var s2 = new Child2();
   console.log(s1.play, s2.play);
   s1.play.push(4);
   console.log(s1.play, s2.play);
   // 缺点：实例共用一个原型对象，会被共同更改，失去了面向对象的意义
   ```

3. 组合方式

   ```js
   // 优点：构造函数的属性和prototype都继承。
   function Parent3 () {
     this.name = 'parent3';
     this.play = [1, 2, 3];
   }
   function Child3 () {
     Parent3.call(this);
     this.type = 'child3';
   }
   Child3.prototype = new Parent3();		//缺点：会调用两次构造函数，实例的constructor指向父构造函数
   // Child3.prototype = Parent3.prototype;	//缺点：实例的constructor指向父构造函数
   var s3 = new Child3();
   var s4 = new Child3();
   s3.play.push(4);
   console.log(s3.play, s4.play);
   ```

4. 组合继承优化

   ```js
   function Parent5 () {
     this.name = 'parent5';
     this.play = [1, 2, 3];
   }
   function Child5 () {
     Parent5.call(this);
     this.type = 'child5';
   }
   // Child5.prototype = Parent5.prototype;  // 优化如下
   // 重新创建对象并赋值原型对象，防止子构造函数的原型赋值constructor后，父构造函数同时改变
   Child5.prototype = Object.create(Parent5.prototype); 
   Child5.prototype.constructor = Child5		// 重新调整指向
   var s5 = new Child5()
   console.log(s5 instanceof Child5,s5 instanceof Parent5);
   console.log(s5.constructor);
   //优点：正确继承父构造函数及其prototype，并且实例的构造函数指向正确
   ```

   

### HTTP协议类

#### HTTP协议的主要特点

* 简单快速 ：因为是统一管理的，想要请求某个资源只需要输入uri
* 灵活：通过一个http协议，就可以完成不同的数据类型传输
* **无连接**：连接一次就会断开
* **无状态**：服务端没有记录当前请求和上次请求是否是同一人（记录是session做的事，不是http协议）

#### HTTP报文的组成方法

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——http协议.png)

##### 	请求报文

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试记录——请求报文.webp)

##### 响应报文

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试记录——响应报文.webp)

#### HTTP方法

* GET ⽅法 

  发送⼀个请求来取得服务器上的某⼀资源 

* POST ⽅法 

  向 URL 指定的资源提交数据或附加新的数据 

* PATCH ⽅法

  表示该请求是一个局部更新

* DELETE ⽅法 

  删除服务器上的某资源

* HEAD

  获取报文首部

#### POST和GET的区别

> 区别记住三四个即可，面试时无需全部回答

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——GET和POST的区别.png)

在GET请求传递的参数长度一般是2kb（2048个字符长度，通常情况下一个英文字符等于一个字节，一个中文字符等于两个字节），每个浏览器支持的长度不一样。

#### HTTP状态码

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——http状态码.png)

#### 什么是持久连接

HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）

当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或重新建立连接。

**注意：Keep-Alive模式只有HTTP1.1版本才支持**

#### 什么是管线化

> 管线化是基于持久连接的

在使用持久连接的情况下，某个连接上消息传递类似于：

`请求1->响应1->请求2->响应2`  即请求一次响应一次

管线化则把连接上的消息变成了如下这样：

`请求1->请求2->响应1->响应2`  即请求一次打包发送，响应也一次性打包给你传递过来

##### 管线化特点

> 面试时记住上面的就够用了，如果面试官深问，讲出前三点即可，或者直接说自己不太了解，问面试官有没有好的书籍资料推荐一下

·管线化机制通过持久连接完成，仅HTTP/1.1支持此技术
·只有GET和HEAD请求可以进行管线化，而POST则有所限制
·初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议·管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变
·HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可
·由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认并未开启管线化支持

### 通信类

#### 什么是同源策略及限制

同源策略限制从一个源加载的文档或脚本与另外一个源的资源交互

而**”源“**指的就是**协议、域名、端口号**

##### 主要限制

* Cookie，LocalStorage和indexDB无法读取
* DOM无法获得
* AJAX请求不能发送

#### 前后端如何通信

* Ajax  (仅支持同源通信)
* WebSocket  （不受同源策略限制）
* CORS （同源和跨域都可以）

#### 如何创建Ajax

* XMLHttpRequest对象的工作流程
* 兼容性处理
* 事件的触发条件
* 事件的触发顺序

#### 跨域通信的几种方式

* JSONP

  原理：利用script标签的异步加载来进行实现，而script又没有跨域限制

  使用：利用js异步创建script标签，并赋值给src一个callback全局函数名，监听script标签的onload，最后把script标签添加到header。通过加载script，回调callback函数并把数据回传过去

* Hash

  ```js
  // 利用hash，场景是当页面A 通过iframe嵌入了跨域的页面B
  
  // 在A中伪代码如下：
  var B = document.getElementsByTagName('iframe');
  B.src = B.src + '#' + 'data';
  // 在B中的伪代码如下
  window.onhashchange = function () {
    var data = window.location.hash;
  };
  ```

* postMessage

  ```js
  // postMessage
  // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
  window.postMessage('data', 'http://B.com');
  // 在窗口B中监听
  window.addEventListener('message', function (event) {
    console.log(event.origin);
    console.log(event.source);
    console.log(event.data);
  }, false);
  ```

* WebSocket

  Websocket【参考资料】http://www.ruanyifeng.com/blog/2017/05/websocket.html

* CORS

  为什么CORS支持跨域：当跨域时浏览器会在请求头中设置一个origin，并检测服务器是否

  ```js
  // CORS【参考资料】http://www.ruanyifeng.com/blog/2016/04/cors.html
  // url（必选），options（可选）
  fetch('/some/url/', {
    method: 'get',
  }).then(function (response) {
  
  }).catch(function (err) {
    // 出错了，等价于 then 的第二个参数，但这样更好用更直观
  });
  ```

  

### 安全类

#### CSRF

##### 基本概念：跨站请求伪造

##### 攻击原理

攻击因素：

1. 这个用户在A网站登入过，如果没有登入B网站是无法进行攻击的
2. A网站的某个接口存在漏洞

![](D:\Vicer\link\study-note\个人向笔记\面试总结\img\面试题记录——CSRF.png)

##### 防御措施

* Token验证   ：点击网站的时候只会自动携带cookie过去，而不会自动携带Token，所以就避免了攻击
* Referer验证：判断这个页面的来源是不是我这个页面，如果不是一律拦截
* 隐藏令牌：隐藏在HTTP的head头中，不会放在连接上

#### XSS

##### 基本概念：跨域脚本攻击

**攻击原理：**通过评论等方式向你的页面注入js文件

防御措施：

1. 将 & < > " ’ / 转义为实体字符

2. cookie设置为http-only

3. 开启CSP网页安全政策

   `<meta http-equiv="Content-Security-Policy" content="">`

### 页面性能

> 提升页面性能的方法有哪些?

1. 资源压缩合并，减少HTTP请求

2. 非核心代码异步加载  ==>  异步加载的方式  ==> 异步加载的区别

   * script的defer方法：在HTML解析完之后执行，如果是多个，按照加载顺序执行（即1、2两个脚本，即使2加载完成也是先执行1）
   * script的async方法：在加载之后立即执行，即使是多个，执行顺序也和加载顺序无关（即1、2两个脚本，2先加载完成先执行2）

3. 利用浏览器缓存 ==> 缓存的分类 ==> 缓存的原理

   * 强缓存：故名思意：强制使用缓存

     ```
     Expires :Thu,21 Jan 2017 23:39:02 GMT   ## 绝对时间，指服务器下发这个时间，在时间之内都是使用缓存（缺点：服务器和客户端时间不一致）
     Cache-Control：max-age=3600（单位：秒）     ## 相对时间：以客户端时间为准，只要超出这个时间就重新请求
     
     注意：如果两个缓存机制都下发了，以Cache-Control（相对时间为准），缓存规定！
     ```

   * 协商缓存：

     ```
     Last-Modified     ## 服务器下发的时间（对比两个文件的更改时间，时间不一致则进行新请求）
     If-Modified-Since  ## 请求的时候带的时间
     Etag 		## 服务器下发的哈希值（当时间变了，内容没有变时，完全可以直接拿缓存）
     If-None-Match   ## 请求时携带的哈希值
     ```

     

4. 使用CDN

5. 预解析DNS：解析页面a标签的href，并对之进行DNS缓存，提升加载速度

   ![浏览器输入URL后过程](https://img-blog.csdnimg.cn/20200517151405154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3MDY0MA==,size_16,color_FFFFFF,t_70)

   ```html
   // 含义：用meta信息来告知浏览器, 当前页面要做DNS预解析。
   // 注意：当页面是http时自动打开预解析；如果页面域名是https时会自动关闭解析。如果需要打开需要如下代码
   <meta http-equiv="x-dns-prefetch-control" content="on">
   
   // 含义：手动对DNS预解析
   <link rel="dns-prefetch" href="//www.zhix.net">
   ```

   

### 错误监控

#### 前端错误的分类

* 及时运行错误：代码错误

* 资源加载错误

#### 错误的捕获方式

##### 及时运行错误捕获

1. `try..catch`
2. `window.onerror`   或者  `window.addEventListener('error',function(e){},false)`

##### 资源加载错误

1. `object.onerror` 如果图片的加载错误，可以用error事件监听（注意：资源的错误无法冒泡，所以`window.onerror`无法监听）

2. `performance.getEntries()`   高级浏览器属性，获取资源的加载时长 ，与`querySelectAll('img')`来进行对比图片数量对比，间接的拿到错误加载资源

3. Error事件捕获（注意：资源加载错误只阻止了事件冒泡，但是没有阻止捕获，所以可用捕获的方法来监听事件错误）

   ```js
   window.addEventListener('error', function (e) {
     console.log('捕获', e);
   }, true);
   ```

扩展：跨域的JS可以捕获嘛，错误提示什么？应该怎么处理？

答：可以，但是错误提示为null，没有权限获取信息

处理方式：

1. 在script标签增加`crossorigin`属性		（前端设置）
2. 设置JS资源响应头为Access-Control-Allow-Origin:*   或对应域名    （后端设置）



#### 上报错误的基本原理

1. 采用Ajax通信的方式上报：可以，但是国内的大公司及监控体系都没有利用这种方法上报

2. 利用Image对象上报

   ```js
   // 一行代码即可进行资源上报，无需借助任何第三方库
   (new Image()).src = 'http://baidu.com/tesjk?r=tksjk';
   ```

   

